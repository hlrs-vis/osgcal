/* -*- c++ -*-
    Copyright (C) 2003 <ryu@gpul.org>
    Copyright (C) 2006 Vladimir Shabanov <vshabanoff@gmail.com>

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/
#ifndef __OSGCAL__MODEL_H__
#define __OSGCAL__MODEL_H__

#include <map>
#include <vector>

#include <osg/Group>
#include <osg/Geometry>

#include <cal3d/cal3d.h>

#include <osgCal/CoreModel>
#include <osgCal/Export>

namespace osgCal {

    /**
     * Updatable class, has update() method, used to update meshes. 
     */
    class Updatable
    {
        public:
            virtual ~Updatable() {}
            virtual void update() = 0;
    };

    // -- Mesh type selection for Model::load --

    enum MeshType
    {
        MT_HARDWARE = 0,

        /**
         * Software meshes are only for testing purpouses. Don't use
         * them in conjunction with hardware meshes.
         */
        MT_SOFTWARE = 1
    };

    struct OSGCAL_EXPORT MeshTyper : public osg::Referenced
    {
            virtual ~MeshTyper() {};
            virtual MeshType type( const CoreModel::Mesh& mesh ) = 0;
    };

    struct OSGCAL_EXPORT AllMeshesHardware : public MeshTyper
    {
            virtual MeshType type( const CoreModel::Mesh& )
            {
                return MT_HARDWARE;
            }
    };

    struct OSGCAL_EXPORT AllMeshesSoftware : public MeshTyper
    {
            virtual MeshType type( const CoreModel::Mesh& )
            {
                return MT_SOFTWARE;
            }
    };
    
    // -- Mesh filtering for Model::load --

    struct OSGCAL_EXPORT MeshFilter : public osg::Referenced
    {
            virtual ~MeshFilter() {};
            virtual bool filter( const CoreModel::Mesh& mesh ) = 0;
    };

    struct OSGCAL_EXPORT AllMeshes : public MeshFilter
    {
            bool filter( const CoreModel::Mesh& ) { return true; }
    };

    struct OSGCAL_EXPORT OneMesh : public MeshFilter
    {
            std::string meshName;

            OneMesh( const std::string& mn )
                : meshName( mn )
            {}

            bool filter( const CoreModel::Mesh& mesh ) { return mesh.data->name == meshName; }
    };

    // -- Model data --

    /**
     * Contains CalModel and skeleton updating functions. It is separated
     * from Model to remove circular references between submeshes and
     * model.
     */
    class ModelData : public osg::Referenced
    {
        public:

            struct BoneParams
            {
                    BoneParams()
                        : bone( 0 )
                        , deformed( false )
                        , changed( false )
                    {}
                    
                    CalBone*     bone;
                    osg::Matrix3 rotation;
                    osg::Vec3f   translation;
                    bool         deformed;
                    bool         changed;
            };

            ModelData( CalModel* cm );
            ~ModelData();

            /**
             * Perform skeleton and BoneParams arrays update.
             * Return true, if something was changed, false otherwise.
             */
            bool update( float deltaTime );

            CalMixer* getCalMixer() { return calMixer; }

            /**
             * Get rotation[9] and translation[3] ready for glUniform[Matrix]3fv.
             * Remark that you must pass not local bone index in mesh,
             * but bone id (using CoreModel::Mesh::getBoneId(index)).
             */
            void getBoneRotationTranslation( int boneId,
                                             GLfloat* rotation,
                                             GLfloat* translation ) const
            {
                const BoneParams& b = bones[ boneId ];
                memcpy( rotation   , b.rotation.ptr()   , 9 * sizeof( GLfloat ) );
                memcpy( translation, b.translation.ptr(), 3 * sizeof( GLfloat ) );
            }
                    
            osg::Matrix getBoneMatrix( int boneId ) const
            {
                const BoneParams&   b = bones[ boneId ];
                const osg::Matrix3& r = b.rotation;
                const osg::Vec3f&   t = b.translation;
                return osg::Matrix( r[0] , r[1] , r[2] , 0.0,
                                    r[3] , r[4] , r[5] , 0.0,
                                    r[6] , r[7] , r[8] , 0.0,
                                    t.x(), t.y(), t.z(), 1.0 );
            }

            const BoneParams& getBoneParams( int boneId ) const
            {
                return bones[ boneId ];
            }

        private:
            
            CalModel*                   calModel;
            CalMixer*                   calMixer;

            typedef std::vector< BoneParams > BoneParamsVector;
            BoneParamsVector            bones;
    };
    
    // -- Model --    
    
    class OSGCAL_EXPORT Model : public osg::Group
    {

        public:

            META_Object(osgCal, Model);

            Model();

        public:

            /**
             * Create model from core model.
             * This function may be called only once.
             */
            void load( CoreModel* coreModel,
                       MeshTyper* meshTyper = 0,
                       MeshFilter* meshFilter = 0 );

            /**
             * Add core model mesh with specified parameters to model.
             */
            void addMesh( const CoreModel::Mesh* mesh,
                          MeshType meshType = MT_HARDWARE,
                          bool useDepthFirstMesh = false );

            /**
             * Add user node to specified bone.
             */
            void addNode( int boneId,
                          osg::Node* node );
            /**
             * Add user drawable to specified bone.
             */
            void addDrawable( int boneId,
                              osg::Drawable* drawable );

            CoreModel* getCoreModel() { return coreModelReference.get(); }
            ModelData* getModelData() { return modelData.get(); }

            /**
             * Update meshes.
             */
            void update( double deltaTime );

            /**
             * Blend animation cycle to the specified weight
             * in specified time.
             */
            void blendCycle( int id,
                             float weight,
                             float delay );

            /**
             * Clear animation cycle in specified amount of time.
             */
            void clearCycle( int id,
                             float delay );

            osg::Geometry* getMesh( const std::string& name ) const throw (std::runtime_error);
            // TODO: return list of geometries

            /**
             * For compiling display lists when accept osgUtil::GLObjectsVisitor.
             */
            virtual void accept( osg::NodeVisitor& nv );

        protected:

            virtual ~Model();

        private:

            Model(const Model&, const osg::CopyOp& copyop=osg::CopyOp::SHALLOW_COPY);

            /**
             * Needed to not destroy animations and caches while model exists.
             */
            osg::ref_ptr< CoreModel >   coreModelReference;
            osg::ref_ptr< ModelData >   modelData;

            typedef std::map< std::string, osg::ref_ptr< osg::Geometry > > MeshMap;

            MeshMap                     meshes;

            // we use matrix transforms for rigid meshes, one transform per bone
            typedef std::map< int, osg::MatrixTransform* > RigidTransformsMap;
            RigidTransformsMap          rigidTransforms;
            std::vector< Updatable* >   updatableMeshes;

            /**
             * Map of used state sets for compilation when
             * GLObjectsVisitor is applied to model.
             */
            std::map< osg::StateSet*, bool > usedStateSets;

    };

}; // namespace osgCal

#endif
