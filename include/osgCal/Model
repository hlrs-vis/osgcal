/* -*- c++ -*-
    Copyright (C) 2003 <ryu@gpul.org>
    Copyright (C) 2006 Vladimir Shabanov <vshabanoff@gmail.com>

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/
#ifndef __OSGCAL__MODEL_H__
#define __OSGCAL__MODEL_H__

#include <map>
#include <vector>

#include <osg/Group>
#include <osg/Geometry>

#include <cal3d/cal3d.h>

#include <osgCal/Export>
#include <osgCal/CoreModel>
#include <osgCal/Mesh>

namespace osgCal {

    // -- Mesh type selection for Model::load --

    enum MeshType
    {
        MT_HARDWARE = 0,

        /**
         * Software meshes are only for testing purpouses. Don't use
         * them in conjunction with hardware meshes.
         */
        MT_SOFTWARE = 1
    };

    // -- Mesh adding for Model::load --

    class Model; // forward

    /**
     * Mesh adder used at load stage. 
     */
    struct OSGCAL_EXPORT BasicMeshAdder : public osg::Referenced
    {
        virtual void add( Model* model,
                          const CoreModel::Mesh* mesh ) = 0;
    };

    /**
     * Default mesh adder -- it adds all meshes as hardware ones.
     */
    struct OSGCAL_EXPORT DefaultMeshAdder : public BasicMeshAdder
    {
        virtual void add( Model* model,
                          const CoreModel::Mesh* mesh );
    };

    struct OSGCAL_EXPORT MeshTyper : public osg::Referenced
    {
        virtual MeshType type( const CoreModel::Mesh* mesh ) = 0;
        virtual bool useDepthFirstMesh( const CoreModel::Mesh* mesh ) = 0;
    };

    struct OSGCAL_EXPORT AllMeshesHardware : public MeshTyper
    {
        bool _useDepthFirstMesh;
        
        AllMeshesHardware( bool useDepthFirstMesh = false )
            : _useDepthFirstMesh( useDepthFirstMesh )
        {}

        virtual MeshType type( const CoreModel::Mesh* )
        {
            return MT_HARDWARE;
        }
        virtual bool useDepthFirstMesh( const CoreModel::Mesh* )
        {
            return _useDepthFirstMesh;
        }
    };

    struct OSGCAL_EXPORT AllMeshesSoftware : public MeshTyper
    {
        virtual MeshType type( const CoreModel::Mesh* )
        {
            return MT_SOFTWARE;
        }
        virtual bool useDepthFirstMesh( const CoreModel::Mesh* ) { return false; }
    };
    

    struct OSGCAL_EXPORT MeshFilter : public osg::Referenced
    {
        virtual bool filter( const CoreModel::Mesh* mesh ) = 0;
    };

    struct OSGCAL_EXPORT AllMeshes : public MeshFilter
    {
        bool filter( const CoreModel::Mesh* ) { return true; }
    };

    struct OSGCAL_EXPORT OneMesh : public MeshFilter
    {
        std::string meshName;

        OneMesh( const std::string& mn )
            : meshName( mn )
        {}

        bool filter( const CoreModel::Mesh* mesh ) { return mesh->data->name == meshName; }
    };

    class MeshAdder : public BasicMeshAdder
    {
        public:
            MeshAdder( MeshFilter* f,
                       MeshTyper*  t )
                : mf( f )
                , mt( t )
            {}

            virtual void add( Model* model,
                              const CoreModel::Mesh* mesh );
        private:
            osg::ref_ptr< MeshFilter > mf;
            osg::ref_ptr< MeshTyper >  mt;
    };

    // -- Model --    
    
    class ModelData; // forward declaration, see after Model

    class OSGCAL_EXPORT Model : public osg::Group
    {

        public:

            META_Object(osgCal, Model);

            Model();

        public:

            /**
             * Create model from core model.
             * This function may be called only once.
             */
            void load( CoreModel* coreModel,
                       BasicMeshAdder* meshAdder = 0 );

            /**
             * Add core model mesh with specified parameters to model.
             */
            void addMesh( const CoreModel::Mesh* mesh,
                          MeshType meshType = MT_HARDWARE,
                          bool useDepthFirstMesh = false );

            /**
             * Add user node to specified bone.
             */
            void addNode( int boneId,
                          osg::Node* node );
            /**
             * Add user drawable to specified bone.
             */
            void addDrawable( int boneId,
                              osg::Drawable* drawable );

            const CoreModel* getCoreModel() const;
            const ModelData* getModelData() const { return modelData.get(); }

            /**
             * Update meshes.
             */
            void update( double deltaTime );

            /**
             * Blend animation cycle to the specified weight
             * in specified time.
             */
            void blendCycle( int id,
                             float weight,
                             float delay );

            /**
             * Clear animation cycle in specified amount of time.
             */
            void clearCycle( int id,
                             float delay );

            typedef std::vector< Mesh* > MeshesList;
            typedef std::map< std::string, MeshesList > MeshMap;

            /**
             * Return list of meshes corresponding to specified name.
             */
            const MeshesList& getMeshes( const std::string& name ) const
                throw (std::runtime_error);

            const MeshMap& getMeshMap() const { return meshes; }

            /**
             * Compiles hardware meshes state sets when accept osgUtil::GLObjectsVisitor.
             */
            virtual void accept( osg::NodeVisitor& nv );

        protected:

            virtual ~Model();

        private:

            Model(const Model&, const osg::CopyOp& copyop=osg::CopyOp::SHALLOW_COPY);

            osg::ref_ptr< ModelData >   modelData;

            MeshMap                     meshes;

            /**
             * Geode where deformable or non-rigged objects are placed.
             */
            osg::ref_ptr< osg::Geode >  geode;

            // we use matrix transforms for rigid meshes and user nodes/drawables,
            // one transform per bone
            typedef std::pair< osg::MatrixTransform*, osg::Geode* > TransformAndGeode;
            typedef std::map< int, TransformAndGeode > RigidTransformsMap;

            RigidTransformsMap          rigidTransforms;

            TransformAndGeode& getOrCreateTransformAndGeode( int boneId );

            std::vector< Mesh* >     updatableMeshes;

            /**
             * Non updatable (rigid) meshes, needed for compiling state sets.
             */
            std::vector< Mesh* >     nonUpdatableMeshes;

    };

    // -- Model data --

    /**
     * Contains CalModel and skeleton updating functions. It is separated
     * from Model to remove circular references between submeshes and
     * model.
     */
    class ModelData : public osg::Referenced
    {
        public:

            struct BoneParams
            {
                    BoneParams()
                        : bone( 0 )
                        , deformed( false )
                        , changed( false )
                    {}
                    
                    CalBone*     bone;
                    osg::Matrix3 rotation;
                    osg::Vec3f   translation;
                    bool         deformed;
                    bool         changed;
            };

            ModelData( CoreModel* cm );
            ~ModelData();

            /**
             * Perform skeleton and BoneParams arrays update.
             * Return true, if something was changed, false otherwise.
             */
            bool update( float deltaTime );

            CalMixer* getCalMixer() { return calMixer; }

            /**
             * Get rotation[9] and translation[3] ready for glUniform[Matrix]3fv.
             * Remark that you must pass not local bone index in mesh,
             * but bone id (using CoreModel::Mesh::getBoneId(index)).
             */
            void getBoneRotationTranslation( int boneId,
                                             GLfloat* rotation,
                                             GLfloat* translation ) const
            {
                const BoneParams& b = bones[ boneId ];
                memcpy( rotation   , b.rotation.ptr()   , 9 * sizeof( GLfloat ) );
                memcpy( translation, b.translation.ptr(), 3 * sizeof( GLfloat ) );
            }
                    
            osg::Matrix getBoneMatrix( int boneId ) const
            {
                const BoneParams&   b = bones[ boneId ];
                const osg::Matrix3& r = b.rotation;
                const osg::Vec3f&   t = b.translation;
                return osg::Matrix( r[0] , r[1] , r[2] , 0.0,
                                    r[3] , r[4] , r[5] , 0.0,
                                    r[6] , r[7] , r[8] , 0.0,
                                    t.x(), t.y(), t.z(), 1.0 );
            }

            const BoneParams& getBoneParams( int boneId ) const
            {
                return bones[ boneId ];
            }

            const CoreModel* getCoreModel() const { return coreModel.get(); }

        private:

            osg::ref_ptr< CoreModel >   coreModel;
            CalModel*                   calModel;
            CalMixer*                   calMixer;

            typedef std::vector< BoneParams > BoneParamsVector;
            BoneParamsVector            bones;
    };
    
}; // namespace osgCal

#endif
