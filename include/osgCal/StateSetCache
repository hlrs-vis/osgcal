/* -*- c++ -*-
    Copyright (C) 2007 Vladimir Shabanov <vshabanoff@gmail.com>

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/
#ifndef __OSGCAL__STATE_SET_CACHE_H__
#define __OSGCAL__STATE_SET_CACHE_H__

#include <map>

#include <osg/Texture2D>
#include <osg/Referenced>
#include <osg/Material>
#include <osg/Fog>
#include <osgCal/Export>
#include <osgCal/Material>
#include <osgCal/Meshes>
#include <osgCal/ShadersCache>

namespace osgCal
{
   /**
     * To maximize state sharing we use separate caches for
     * osg::Material, osg::Texture2D, osg::StateSet (SoftwareMaterial,
     * for software meshes),
     * osg::Program and osg::StateSet (Material, with shaders).
     *
     * Here is an internal cache hierarchy (the keys are shown in brakets):
     *
     * HardwareMeshStateSetCache[Material]
     *  |- SoftwareMeshStateSetCache[SoftwareMaterial]
     *  |- -|- TexturesCache[TextureDesc]
     *  |   \- MaterialsCache[OsgMaterial]
     *  \- ShadersCache[ShaderFlags]
     */
    class MaterialsCache : public osg::Referenced
    {
        public:
            osg::Material* get( const OsgMaterial& md );

        private:
            typedef std::map< OsgMaterial, osg::Material* > Map;
            Map cache;

            osg::Material* createMaterial( const OsgMaterial& desc );
    };

    class TexturesCache : public osg::Referenced
    {
        public:
            osg::Texture2D* get( const TextureDesc& td );

        private:
            typedef std::map< TextureDesc, osg::Texture2D* > Map;
            Map cache;
            
            osg::Texture2D* createTexture( const TextureDesc& fileName )
                throw (std::runtime_error);
    };

    class SwMeshStateSetCache : public osg::Referenced
    {
        public:
            SwMeshStateSetCache( MaterialsCache* mc,
                                 TexturesCache*  tc );
            
            osg::StateSet* get( const SoftwareMaterial& swsd );

        private:
            typedef std::map< SoftwareMaterial, osg::StateSet* > Map;

            Map cache;
            osg::ref_ptr< MaterialsCache > materialsCache;
            osg::ref_ptr< TexturesCache >  texturesCache;

            osg::StateSet* createSwMeshStateSet( const SoftwareMaterial& swsd );
    };

    class HwMeshStateSetCache : public osg::Referenced
    {
        public:
            HwMeshStateSetCache( SwMeshStateSetCache* swssc,
                                 TexturesCache*       tc,
                                 ShadersCache*        sc );
            
            osg::StateSet* get( const Material& swsd,
                                int             bonesCount,
                                bool            useDepthFirstMesh );

            int flags;

        private:
            // map from < state desc, < bones count, useDepthFirstMesh > >
            typedef std::map< std::pair< Material, std::pair< int, bool > >,
                              osg::StateSet* > Map;

            Map cache;
            osg::ref_ptr< SwMeshStateSetCache > swMeshStateSetCache;
            osg::ref_ptr< TexturesCache >       texturesCache;
            osg::ref_ptr< ShadersCache >        shadersCache;

            osg::StateSet* createHwMeshStateSet(
                const std::pair< Material, std::pair< int, bool > >& matAndBones );
    };

    class DepthMeshStateSetCache : public osg::Referenced
    {
        public:
            DepthMeshStateSetCache( ShadersCache* sc )
                : flags( 0 )
                , shadersCache( sc )                  
            {}
            osg::StateSet* get( const Material& material,
                                int             bonesCount );

            int flags;

        private:
            // map from < bone count, sides count > to stateset
            typedef std::map< std::pair< int, int >, osg::StateSet* > Map;

            Map cache;
            osg::ref_ptr< ShadersCache >        shadersCache;

            osg::StateSet* createDepthMeshStateSet( const std::pair< int, int >& boneAndSidesCount );
    };

    class StateSetCache : public osg::Referenced
    {
        public:

            StateSetCache();

            osg::ref_ptr< SwMeshStateSetCache >     swMeshStateSetCache;
            osg::ref_ptr< HwMeshStateSetCache >     hwMeshStateSetCache;
            osg::ref_ptr< DepthMeshStateSetCache >  depthMeshStateSetCache;

            /**
             * Return global state set cache instance. Instance is
             * keeped inside osg::observer_ptr so it will be removed
             * when last reference to StateSetCache is removed. Also
             * instance does not exists until first instance() call.
             */
            static StateSetCache* instance();
            
    };

}; // namespace osgCal

#endif
